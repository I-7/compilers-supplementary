-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

var ops = {
  [Left, {
    [ s("&&"), fun (l, op, r) { Binop ("&&", l, r) } ],
    [ s("!!"), fun (l, op, r) { Binop ("!!", l, r) } ]
    }],
  [Nona, {
    [ s("<"), fun (l, op, r) { Binop ("<", l, r) } ],
    [ s(">"), fun (l, op, r) { Binop (">", l, r) } ],
    [ s("<="), fun (l, op, r) { Binop ("<=", l, r) } ],
    [ s(">="), fun (l, op, r) { Binop (">=", l, r) } ],
    [ s("=="), fun (l, op, r) { Binop ("==", l, r) } ],
    [ s("!="), fun (l, op, r) { Binop ("!=", l, r) } ]
    }],
  [Left, {
    [ s("+"), fun (l, op, r) { Binop ("+", l, r) } ],
    [ s("-"), fun (l, op, r) { Binop ("-", l, r) } ]
    }],
  [Left, {
    [ s("*"), fun (l, op, r) { Binop ("*", l, r) } ],
    [ s("/"), fun (l, op, r) { Binop ("/", l, r) } ],
    [ s("%"), fun (l, op, r) { Binop ("%", l, r) } ]
    }]
};

-- Primary expression
var primary = memo $ eta (decimal @ fun (x) {Const (stringInt (x))} |
                          lident  @ fun (x) {Var (x)} |
                          inbr (s ("("), exp, s (")"))),
    exp = memo $ eta expr(ops, primary);

var openedIf = memo $ eta syntax (
  x=exp kThen y=stmtMulty { If (x, y, Skip) } |
  x=exp kThen y=stmtMulty kElse z=stmtMulty { If (x, y, z) } |
  x=exp kThen y=stmtMulty kElif z=openedIf { If (x, y, z) }
);

var stmt = memo $ eta syntax (
  kRead s["("] x=lident s[")"] { Read (x) } |
  kWrite s["("] x=exp s[")"] { Write (x) } |
  kSkip { Skip } |
  lv=lident s[":="] rv=exp { Assn (lv, rv) } |
  kIf x=exp kThen y=stmtMulty kFi { If (x, y, Skip) } |
  kIf x=exp kThen y=stmtMulty kElse z=stmtMulty kFi { If (x, y, z) } |
  kIf x=exp kThen y=stmtMulty kElif z=openedIf kFi { If (x, y, z) } |
  kWhile x=exp kDo y=stmtMulty kOd { While (x, y) } |
  kDo x=stmtMulty kWhile y=exp kOd { DoWhile (x, y) } |
  kFor ini=stmt s[","] cond=exp s[","] post=stmtMulty kDo body=stmtMulty kOd { Seq (ini, While (cond, Seq (body, post))) }
);

var stmtMulty = memo $ eta syntax (
  stmt |
  l=stmt s[";"] r=stmtMulty { Seq (l, r) }
);

-- Public top-level parser
public parse = stmtMulty;
