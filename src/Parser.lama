-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

var ops = {
  [Left, {
    [ s("&&"), fun (l, op, r) { Binop ("&&", l, r) } ],
    [ s("!!"), fun (l, op, r) { Binop ("!!", l, r) } ]
    }],
  [Nona, {
    [ s("<"), fun (l, op, r) { Binop ("<", l, r) } ],
    [ s(">"), fun (l, op, r) { Binop (">", l, r) } ],
    [ s("<="), fun (l, op, r) { Binop ("<=", l, r) } ],
    [ s(">="), fun (l, op, r) { Binop (">=", l, r) } ],
    [ s("=="), fun (l, op, r) { Binop ("==", l, r) } ],
    [ s("!="), fun (l, op, r) { Binop ("!=", l, r) } ]
    }],
  [Left, {
    [ s("+"), fun (l, op, r) { Binop ("+", l, r) } ],
    [ s("-"), fun (l, op, r) { Binop ("-", l, r) } ]
    }],
  [Left, {
    [ s("*"), fun (l, op, r) { Binop ("*", l, r) } ],
    [ s("/"), fun (l, op, r) { Binop ("/", l, r) } ],
    [ s("%"), fun (l, op, r) { Binop ("%", l, r) } ]
    }]
};

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
      exp = memo $ eta expr(ops, primary);

var stmt = memo $ eta syntax (
  -kRead s["("] x=lident s[")"] { Read (x) } |
  -kWrite s["("] x=exp s[")"] { Write (x) } |
  -kSkip { Skip } |
  lv=lident s[":="] rv=exp { Assn (lv, rv) }
);

var stmtMulty = memo $ eta syntax (
  x=stmt { x } |
  l=stmt s[";"] r=stmtMulty { Seq (l, r) }
);

-- Public top-level parser
public parse = stmtMulty;
             
